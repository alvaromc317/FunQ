% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fqpca-utils.R
\name{fqpca_cv_df}
\alias{fqpca_cv_df}
\title{CROSS VALIDATION OF DEGREES OF FREEDOM}
\usage{
fqpca_cv_df(
  data,
  colname = NULL,
  npc = 2,
  pve = NULL,
  quantile.value = 0.5,
  lambda.ridge = 0,
  n.folds = 3,
  return.models = TRUE,
  criteria = "points",
  periodic = TRUE,
  splines.df.grid = c(5, 10, 15, 20),
  tol = 0.001,
  max.iters = 20,
  splines.method = "conquer",
  penalized = FALSE,
  parallelized.scores = FALSE,
  num.cores = NULL,
  verbose.fqpca = FALSE,
  verbose.cv = TRUE,
  seed = NULL
)
}
\arguments{
\item{data}{An \eqn{(N \times T)} matrix, a tf object from the tidyfun package or a data.frame containing the functional data as a tf column.}

\item{colname}{The name of the column containing the functional data. Use only if data is a dataframe and colname is a column in the dataframe.}

\item{npc}{The number of estimated components.}

\item{pve}{Float between 0 and 1. Percentage of variability explained by components. This affects the number of components used in the curve reconstruction and error estimation. Set to NULL to avoid this behavior.}

\item{quantile.value}{The quantile considered.}

\item{lambda.ridge}{Hyper parameter controlling the penalization on the second derivative of the splines. It has effect only with \code{penalized=TRUE} and \code{method='conquer'}.}

\item{n.folds}{Number of folds to be used on cross validation.}

\item{return.models}{Should the list of all the models built be returned?}

\item{criteria}{Criteria used to divide the data. Valid values are \code{'rows'}, which considers the division based on full rows, or \code{'points'}, which considers the division based on points within the matrix.}

\item{periodic}{Boolean indicating if the data is expected to be periodic (start coincides with end) or not.}

\item{splines.df.grid}{Grid of possible values for the degrees of freedom.}

\item{tol}{Tolerance on the convergence of the algorithm.}

\item{max.iters}{Maximum number of iterations.}

\item{splines.method}{Method used in the resolution of the splines quantile regression model. It currently accepts the methods \code{c('conquer', 'quantreg')}.}

\item{penalized}{Boolean indicating if the smoothness should be controlled using a second derivative penalty. This functionality is experimental.}

\item{parallelized.scores}{Should the scores be computed in parallel? Experimantal component.}

\item{num.cores}{Number of cores to use in parallelized executions.}

\item{verbose.fqpca}{Boolean indicating verbosity of the fqpca function.}

\item{verbose.cv}{Boolean indicating verbosity of the cross-validation process.}

\item{seed}{Seed for the random generator number.}
}
\value{
A list containing the matrix of scores, the matrix of loadings, and a secondary list with extra information.
}
\description{
Performs cross validation on degrees of freedom parameter of fqpca
}
\examples{
n.obs = 150
n.time = 144

# Generate scores
c1.vals = rnorm(n.obs)
c2.vals = rnorm(n.obs)

# Generate pc's
pc1 = sin(seq(0, 2*pi, length.out = 144))
pc2 = cos(seq(0, 2*pi, length.out = 144))

# Generate data
Y <- c1.vals * matrix(pc1, nrow = n.obs, ncol=n.time, byrow = TRUE) +
c2.vals * matrix(pc2, nrow = n.obs, ncol=n.time, byrow = TRUE)

# Add noise
Y <- Y + matrix(rnorm(n.obs * n.time, 0, 0.4), nrow = n.obs)

# Add missing observations
Y[sample(n.obs*n.time, as.integer(0.2*n.obs*n.time))] <- NA

cv_result <- fqpca_cv_df(data=Y, splines.df.grid = c(5, 10, 15), n.folds = 2)
}
