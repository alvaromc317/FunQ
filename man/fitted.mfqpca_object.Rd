% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mfqpca.R
\name{fitted.mfqpca_object}
\alias{fitted.mfqpca_object}
\title{Fit Yhat}
\usage{
\method{fitted}{mfqpca_object}(object, pve.between = 0.95, pve.within = 0.95, ...)
}
\arguments{
\item{object}{An object output of the fqpca function.}

\item{pve.between}{If smaller than 1, taken as percentage of explained variability used in Yhat estimation. If greater than 1, taken as number of components  used in Yhat estimation.}

\item{pve.within}{If smaller than 1, taken as percentage of explained variability used in Yhat estimation. If greater than 1, taken as number of components  used in Yhat estimation.}

\item{...}{further arguments passed to or from other methods.}
}
\value{
The normalized matrix of scores.
}
\description{
S3 method for class 'mfqpca_object'. Given an mfqpca_object model, estimates Yhat for different pve values.
}
\examples{

n.individuals <- 20
n.repeated <- 10
n.time = 144
N <- n.repeated * n.individuals

group <- rep(1:n.individuals, each=n.repeated)

# Define score values using a normal distribution
c1.vals <- rnorm(n.individuals)
c1.vals <- c1.vals[match(group, unique(group))]
c2.vals <- rnorm(N)

# Define principal components
pcb <- sin(seq(0, 2*pi, length.out = n.time))
pcw <- cos(seq(0, 2*pi, length.out = n.time))

# Generate a data matrix and add missing observations
Y <- c1.vals * matrix(pcb, nrow = N, ncol=n.time, byrow = TRUE) +
c2.vals * matrix(pcw, nrow = N, ncol=n.time, byrow = TRUE)
Y <- Y + matrix(rnorm(N*n.time, 0, 0.4), nrow = N)
Y[sample(N*n.time, as.integer(0.2*N))] <- NA

results <- mfqpca(data = Y, group=group, npc.between = 1, npc.within=1, quantile.value = 0.5)
Yhat <- fitted(object = results, pve.between=0.95, pve.within=0)

}
